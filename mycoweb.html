collectibleDot.style.left = Math.random() * (gameContainer.offsetWidth * 4) + 'px';
            collectibleDot.style.top = Math.random() * (gameContainer.offsetHeight * 0.7) + 'px';
            collectibleDot.style.opacity = 0.8; // Ensure opacity
            const dx = (Math.random() > 0.5 ? 1 : -1) * collectibleSpeed;
            const dy = (Math.random() > 0.5 ? 1 : -1) * collectibleSpeed;
            collectiblesContainer.appendChild(collectibleDot);
            collectibles.push({ element: collectibleDot, x: parseFloat(collectibleDot.style.left), y: parseFloat(collectibleDot.style.top), dx: dx, dy: dy });
            console.log("Collectible spawned:", collectibleDot); // Debugging log
        }

        // Generate level complete text grid
        function generateCompleteTextGrid() {
            let currentX = 0;
            completionText.split('').forEach(letter => {
                if (textGridConfig[letter]) {
                    textGridConfig[letter].forEach(coord => {
                        completeTextGrid.push({ x: coord[0] + currentX, y: coord[1] });
                    });
                    currentX += (Math.max(...textGridConfig[letter].map(c => c[0])) + letterSpacing);
                }
            });
            const allX = completeTextGrid.map(c => c.x);
            const allY = completeTextGrid.map(c => c.y);
            textGridOffset.x = -Math.floor((Math.max(...allX) - Math.min(...allX) + 1) / 2);
            textGridOffset.y = -Math.floor((Math.max(...allY) - Math.min(...allY) + 1) / 2);
            levelCompleteTextElement.style.gridTemplateColumns = `repeat(${Math.max(...allX) - Math.min(...allX) + 1}, ${playerDotSize - 2 + 3}px)`;
            levelCompleteTextElement.style.gridTemplateRows = `repeat(${Math.max(...allY) - Math.min(...allY) + 1}, ${playerDotSize - 2 + 3}px)`;
        }

        // Display level complete text
        function displayCompleteText() {
            levelCompleteTextElement.innerHTML = '';
            completeTextGrid.forEach(coord => {
                const dot = createDot('complete-dot', playerDotSize - 2);
                dot.style.gridColumn = coord.x + textGridOffset.x + 1;
                dot.style.gridRow = coord.y + textGridOffset.y + 1;
                levelCompleteTextElement.appendChild(dot);
            });
            levelCompleteTextElement.style.opacity = 1;
        }

        // Get new attachment position for player growth
        function getNewAttachmentPosition() {
            const allPlayerPositions = playerBody.map(p => `${p.x},${p.y}`);
            const possibleAttachments = [];

            playerBody.forEach(part => {
                [-1, 1].forEach(offset => {
                    const hPos = `${part.x + offset},${part.y}`;
                    const vPos = `${part.x},${part.y + offset}`;
                    if (!allPlayerPositions.includes(hPos)) possibleAttachments.push({ x: part.x + offset, y: part.y });
                    if (!allPlayerPositions.includes(vPos)) possibleAttachments.push({ x: part.x, y: part.y + offset });
                });
            });

            if (possibleAttachments.length > 0) {
                const randomIndex = Math.floor(Math.random() * possibleAttachments.length);
                return possibleAttachments[randomIndex];
            }
            return null;
        }

        // Function to show and hide dimensional text with fade
        function cycleDimensionalText() {
            if (levelComplete) return; // Stop if the level is complete

            if (isDimensionalTextVisible) {
                dimensionalTextElement.classList.remove('visible');
                currentDimensionalTextTimeout = setTimeout(cycleDimensionalText, Math.random() * (textUpdateIntervalMax - textUpdateIntervalMin) + textUpdateIntervalMin + textFadeOutDuration);
                isDimensionalTextVisible = false;
            } else {
                dimensionalTextElement.textContent = getRandomDimensionalSaying();
                dimensionalTextElement.classList.add('visible');
                currentDimensionalTextTimeout = setTimeout(cycleDimensionalText, textFadeOutDuration + Math.random() * (textUpdateIntervalMax - textUpdateIntervalMin) + textUpdateIntervalMin);
                isDimensionalTextVisible = true;
            }
        }

        // Main game loop
        function updateGame(timestamp) {
            let dx = 0;
            let dy = 0;

            // Handle player movement
            if (keysPressed['ArrowLeft']) dx = -playerSpeed;
            if (keysPressed['ArrowRight']) dx = playerSpeed;
            if (keysPressed['ArrowUp']) dy = -playerSpeed;
            if (keysPressed['ArrowDown']) dy = playerSpeed;

            // Update player position
            playerX += dx;
            playerY += dy;

            // Keep player in bounds
            const playerRect = playerElement.getBoundingClientRect();
            playerX = Math.max(0, Math.min(playerX, gameContainer.offsetWidth - playerRect.width));
            playerY = Math.max(0, Math.min(playerY, gameContainer.offsetHeight - playerRect.height));

            playerElement.style.left = playerX + 'px';
            playerElement.style.top = playerY + 'px';

            hasGrownThisFrame = false;

            if (!levelComplete) {
                // Move path infinitely
                pathPosition -= pathSpeed;
                path.forEach(segment => {
                    segment.element.style.transform = `translateX(${pathPosition % (pathSegmentLength * (dotSize + 2))}px)`;
                });

                // Spawn new collectibles very frequently
                const now = Date.now();
                if (now - lastCollectibleSpawnTime > collectibleSpawnInterval) {
                    spawnCollectible();
                    lastCollectibleSpawnTime = now;
                    // Increase spawn frequency slightly over time
                    collectibleSpawnInterval = Math.max(100, collectibleSpawnInterval - 10);
                }

                // Spawn fleeting faces
                if (now - lastFaceSpawnTime > faceSpawnInterval) {
                    spawnFleetingFace();
                    lastFaceSpawnTime = now;
                }

                // Update collectible positions and check for collision
                for (let i = collectibles.length - 1; i >= 0; i--) {
                    const collectible = collectibles[i];
                    const element = collectible.element;

                    collectible.x += collectible.dx;
                    collectible.y += collectible.dy;

                    // Bounce off the walls
                    if (collectible.x < 0 || collectible.x > gameContainer.offsetWidth - parseFloat(element.style.width)) {
                        collectible.dx *= -1;
                    }
                    if (collectible.y < 0 || collectible.y > gameContainer.offsetHeight * 0.8 - parseFloat(element.style.height)) {
                        collectible.dy *= -1;
                    }

                    element.style.left = collectible.x + 'px';
                    element.style.top = collectible.y + 'px';

                    const collectibleRect = element.getBoundingClientRect();
                    const playerRect = playerElement.getBoundingClientRect();
                    if (playerRect.left < collectibleRect.right &&
                        playerRect.right > playerRect.left &&
                        playerRect.top < collectibleRect.bottom &&
                        playerRect.bottom > playerRect.top &&
                        !hasGrownThisFrame) {
                        const newPosition = getNewAttachmentPosition();
                        if (newPosition) {
                            playerBody.push(newPosition);
                            updatePlayerDisplay();
                            hasGrownThisFrame = true;
                        }
                        element.remove();
                        collectibles.splice(i, 1);
                        dotsCollected++;
                        console.log(`Collected ${dotsCollected} / ${dotsToWin}, Size: ${playerBody.length}`);

                        if (dotsCollected >= dotsToWin) {
                            levelComplete = true; // Stop the level
                            displayCompleteText(); // Display the ASCENSION message
                            clearTimeout(currentDimensionalTextTimeout); // Stop dimensional text cycling
                            dimensionalTextElement.classList.remove('visible');
                            console.log("Level complete!");
                            // Optionally stop spawning collectibles or change game state here
                        } else if (dotsCollected >= dotsToWin * 0.75 && !writingAssembled) {
                            assembledWritingElement.textContent = assembledMessage;
                            assembledWritingElement.style.opacity = 1;
                            writingAssembled = true;
                            console.log("The assembled writing appears!");
                        }
                        break;
                    }
                }

                // Check path collision
                for (const segment of path) {
                    const pathRect = segment.element.getBoundingClientRect();
                    const playerTrueRect = playerElement.getBoundingClientRect(); // Use the actual rendered size
                    if (playerTrueRect.left < pathRect.right &&
                        playerTrueRect.right > pathRect.left &&
                        playerTrueRect.top < pathRect.bottom &&
                        playerTrueRect.bottom > pathRect.top) {
                        console.log("Glimpse of the abyss!");
                        // Game over logic here (for now, just logging)
                    }
                }
            }

            requestAnimationFrame(updateGame);
        }

        // Start game function
        function startGame() {
            titleScreen.style.display = 'none';
            gameContainer.style.display = 'block';
            dotsCollected = 0;
            currentLevel = 1;
            dotsToWin = 1000; // Set initial target
            levelComplete = false;
            playerBody = [{ x: 0, y: 0 }];
            playerX = 50;
            playerY = 400;
            collectiblesContainer.innerHTML = '';
            collectibles = [];
            collectibleSpawnInterval = 1000; // Very frequent start
            lastCollectibleSpawnTime = 0;
            lastFaceSpawnTime = 0; // Initialize face spawn timer
            pathContainer.innerHTML = '';
            pathPosition = 0;
            initializePath();
            initializeCollectibles();
            updatePlayerDisplay();
            playerElement.style.left = playerX + 'px';
            playerElement.style.top = playerY + 'px';
            lastTextUpdateTime = performance.now(); // Initialize text update timer
            assembledWritingElement.style.opacity = 0;
            writingAssembled = false;
            isDimensionalTextVisible = false;
            clearTimeout(currentDimensionalTextTimeout);
            cycleDimensionalText(); // Start the dimensional text cycling
            updateGame(performance.now());
        }

        // Initialize complete text
        generateCompleteTextGrid();
        // Start button listener
        startButton.addEventListener('click', startGame);

        // Random number helper
        function random() {
            return Math.random();
        }

        // Event listeners for key presses
        document.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });
    </script>
</body>
</html>
